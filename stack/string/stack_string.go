// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

// Package stackstring provides stack implementations
// safe for concurrent operations on string values
package stackstring

import (
	"fmt"
	"sync"
)

// Stack provides methods for stack operations
type Stack interface {
	// Push allows pushing of string element onto the stack
	Push(string)
	// Pop will return the last element from the stack and remove it
	Pop() string
	// Peek returns the an from the stack but does not removes it
	Peek() string
	// Empty checks if the stack is empty
	Empty() bool
	// Full checks if the stack is full
	Full() bool
	// Size returns the current size of the stack
	Size() int
	// Print will print the stack elements
	Print()
}

const (
	defaultSize = 100
	upperLimit  = 10000000
)

type ssStruct struct {
	stackR []string
	indx   int
	l      sync.RWMutex
}

var ln int

// NewStack returns a new stack for string elements,
// with default size of 100,
// which can be overwritten by an
// optional positive integer parameter.
//
// Paramter must be less than 10000000,
// else it panics!
func NewStack(s ...int) Stack {
	ln = defaultSize
	if s != nil && s[0] > 0 {
		ln = s[0]
	}
	if ln > upperLimit {
		panic("Stack size exceeds upper limit")
	}
	return &ssStruct{
		stackR: make([]string, ln),
		indx:   0,
	}
}

// Push allows pushing of string element onto the stack
func (s *ssStruct) Push(el string) {
	s.l.Lock()
	defer s.l.Unlock()
	if s.indx < len(s.stackR) {
		s.stackR[s.indx] = el
		s.indx++
	}
}

// Pop will get the last element from the stack, and delete it
func (s *ssStruct) Pop() string {
	s.l.Lock()
	defer s.l.Unlock()
	if s.indx < 1 {
		return ""
	}
	s.indx--
	el := s.stackR[s.indx]
	s.stackR[s.indx] = ""
	return el
}

// Peek returns the an from the stack but does not removes it
func (s *ssStruct) Peek() string {
	s.l.RLock()
	defer s.l.RUnlock()
	if s.indx < 1 {
		return ""
	}
	e := s.stackR[s.indx-1]
	return e
}

// Empty checks if the stack is empty
func (s *ssStruct) Empty() bool {
	s.l.RLock()
	defer s.l.RUnlock()
	truthy := s.indx == 0
	return truthy
}

// Full checks if the stack is full
func (s *ssStruct) Full() bool {
	s.l.RLock()
	defer s.l.RUnlock()
	truthy := s.indx >= ln
	return truthy
}

// Size returns the current size of the stack
func (s *ssStruct) Size() int {
	s.l.RLock()
	defer s.l.RUnlock()
	l := s.indx
	return l
}

// Print will print the stack elements
func (s *ssStruct) Print() {
	s.l.RLock()
	defer s.l.RUnlock()
	for i := 0; i <= s.indx; i++ {
		fmt.Printf("%s ", s.stackR[i])
	}
	fmt.Println()
}
